#!/usr/bin/env ruby

$LOAD_PATH.unshift './lib'

require 'brotli'
require 'csv'
require 'httparty'
require 'json'
require 'lord_of_war/monkeypatch'
require 'nokogiri'
require 'pry'
require 'securerandom'
require 'set'
require 'sqlite3'
require 'thor'
require_relative 'utils'

class Tactishop < Thor
  include Utils

  DATA_FOLDER = "#{File.dirname __FILE__}/../data/airsoftzone"

  BASE_URL = 'https://airsoftzone.com.mx/wp-json/wp/v2/pages'

  STAGES = %w[urls details clean audit]

  desc 'scrap', 'Scrap site'
  option :from, type: :string, default: 'urls', desc: "Start scraping from a given stage. Valid options: #{STAGES.join ", "}"
  option :audit, type: :boolean, deafult: false
  def scrap
    initial_stage = STAGES.find_index options[:from]

    urls = if initial_stage > 0 # urls
             puts '[*] Loading URLs from cache...'
             JSON.parse File.read("#{DATA_FOLDER}/product_urls.json")
           else
             urls = scrap_products_list
             File.write "#{DATA_FOLDER}/product_urls.json", urls.to_json

             existing = {}
             urls.select do |hsh|
               if existing.key? hsh['url']
                 false
               else
                 existing[hsh['url']] = true
                 true
               end
             end
           end

    products = if initial_stage > 1 # details
                 puts '[*] Loading product details from cache...'
                 JSON.parse File.read("#{DATA_FOLDER}/product_details.json")
               else
                 products = scrap_product_details urls
                 File.write "#{DATA_FOLDER}/product_details.json", products.to_json

                 products
               end

    clean_products = if initial_stage > 2 # clean
                       puts '[*] Loading clean products from cache...'
                       JSON.parse File.read("#{DATA_FOLDER}/clean.json")
                     else
                       clean_products = clean_records products
                       File.write "#{DATA_FOLDER}/clean.json", clean_products.to_json

                       clean_products
                     end

    audit_props DATA_FOLDER, clean_products if options[:audit]

    puts '[+] Done!'
  end

  desc 'upload FILE', 'Load data in DB'
  def upload(file)
    records = JSON.parse File.read(file)

    db = SQLite3::Database.new 'low.db'
    db.results_as_hash = true

    ins_products_sql = <<~SQL
      INSERT INTO products(id, search_corpus, title, url, description, price, capacity_id, category_id, fps_range_id, gearbox_id, hop_up_id, inner_barrel_id, magazine_id, motor_id, outer_barrel_id, speed_id, system_id, thread_direction_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
      RETURNING id
    SQL

    upd_products_sql = <<~SQL
      UPDATE products SET
      search_corpus = $2, title = $3, url = $4, description = $5, price = $6, capacity_id = $7, category_id = $8,#{" "}
      fps_range_id = $9, gearbox_id = $10, hop_up_id = $11, inner_barrel_id = $12, magazine_id = $13, motor_id = $14,#{" "}
      outer_barrel_id = $15, speed_id = $16, system_id = $17, thread_direction_id = $18
      WHERE id = $1
      RETURNING id
    SQL

    count = 0
    records.each do |rec|
      count += 1
      print "  #{count} / #{records.size} ...      \r"

      capacity_id = fetch_or_create 'capacities', rec['capacity'], db
      category_id = fetch_or_create 'categories', rec['category'], db
      fps_range_id = fetch_or_create 'fps_ranges', rec['fps_range'], db
      gearbox_id = fetch_or_create 'gearboxes', rec['gearbox'], db
      hop_up_id = fetch_or_create 'hop_ups', rec['hop_up'], db
      inner_barrel_id = fetch_or_create 'inner_barrels', rec['inner_barrel'], db
      magazine_id = fetch_or_create 'magazines', rec['magazine'], db
      motor_id = fetch_or_create 'motors', rec['motor'], db
      outer_barrel_id = fetch_or_create 'outer_barrels', rec['outer_barrel'], db
      speed_id = fetch_or_create 'speeds', rec['speed'], db
      system_id = fetch_or_create 'systems', rec['system'], db
      thread_direction_id = fetch_or_create 'thread_directions', rec['thread_direction'], db

      is_new_product = db
                       .execute('SELECT id FROM products WHERE id = $1', [rec['id']])
                       .map { |p| p['id'] }
                       .first
                       .nil?

      product_id = if is_new_product
                     db.execute(
                       ins_products_sql,
                       [
                         rec['id'],
                         rec['search_corpus'],
                         rec['title'],
                         rec['url'],
                         rec['description'],
                         rec.dig('price', 'amount'),
                         capacity_id,
                         category_id,
                         fps_range_id,
                         gearbox_id,
                         hop_up_id,
                         inner_barrel_id,
                         magazine_id,
                         motor_id,
                         outer_barrel_id,
                         speed_id,
                         system_id,
                         thread_direction_id,
                       ]
                     ).map { |row| row['id'] }.first
                   else
                     db.execute(
                       upd_products_sql,
                       [
                         rec['search_corpus'],
                         rec['title'],
                         rec['url'],
                         rec['description'],
                         rec.dig('price', 'amount'),
                         capacity_id,
                         category_id,
                         fps_range_id,
                         gearbox_id,
                         hop_up_id,
                         inner_barrel_id,
                         magazine_id,
                         motor_id,
                         outer_barrel_id,
                         speed_id,
                         system_id,
                         thread_direction_id,
                         rec['id'],
                       ]
                     ).map { |row| row['id'] }.first
                   end

      (rec['battery'] || []).each do |val|
        val['capacity'].product(val['type']).each do |cap, tp|
          calc_val = "#{cap} #{tp}"

          battery_id = fetch_or_create 'batteries', calc_val, db
          create_product_relation_if_required 'products_batteries', 'battery_id', product_id, battery_id, db
        end
      end

      (rec['firing_mode'] || []).each do |val|
        firing_mode_id = fetch_or_create 'firing_modes', val, db
        create_product_relation_if_required 'products_firing_modes', 'firing_mode_id', product_id, firing_mode_id, db
      end

      (rec['img'] || []).each do |val|
        img_id = fetch_or_create 'imgs', val, db
        create_product_relation_if_required 'products_imgs', 'img_id', product_id, img_id, db
      end

      (rec['license'] || []).each do |val|
        license_id = fetch_or_create 'licenses', val, db
        create_product_relation_if_required 'products_licenses', 'license_id', product_id, license_id, db
      end

      (rec['maker'] || []).each do |val|
        maker_id = fetch_or_create 'makers', val, db
        create_product_relation_if_required 'products_makers', 'maker_id', product_id, maker_id, db
      end

      (rec['type'] || []).each do |val|
        type_id = fetch_or_create 'types', val, db
        create_product_relation_if_required 'products_types', 'type_id', product_id, type_id, db
      end
    rescue StandardError => e
      binding.pry
    end
  end

  no_commands do
    def overwrite_category_by_url!(acc, prod)
      if prod['description'].match?(/\breplica\b/i)
        acc['category'] = 'replica'
      elsif acc['category'] == 'unknown'
        acc['category'] = detect_category prod['description']
      end
    end

    def clean_records(products)
      error_reports = {}

      clean_products = products.each_with_object({}) do |prod, acc|
        acc[prod['url']] = prod.each_with_object(Hash.new { |h, k| h[k] = [] }) do |(key, value), acc2|
          key = props_dict.fetch clean_prop_name(key), key

          unless allowed_keys.include? key
            unless error_reports.key? key
              error_reports[key] = true
              puts "[-] Key [#{key}] not allowed"
            end
            next
          end

          case key
          when 'title'
            acc2.merge! extract_title_info(value)
            overwrite_category_by_url! acc2, prod
            cval = clean_title value
            acc2[key] = cval
          when 'battery'
            cval = clean_battery value
            acc2[key].concat cval
          when 'fps_range'
            cval = clean_fps_range value
            acc2[key] = cval
          when 'gearbox'
            cval = clean_gearbox value
            acc2[key] = cval
          when 'hop_up'
            cval = clean_hop_up value
            acc2[key] = cval
          when 'inner_barrel'
            cval = clean_inner_barrel value
            acc2[key] = cval
          when 'magazine'
            cval = clean_magazine value
            acc2[key] = cval
          when 'maker'
            cval = clean_maker value
            acc2[key].concat cval
          when 'motor'
            cval = clean_motor value
            acc2[key] = cval
          when 'price'
            cval = clean_price value
            acc2[key] = cval
          when 'speed'
            cval = clean_speed value
            acc2[key] = cval
          when 'system'
            cval = clean_system value
            acc2[key] = cval
          when 'thread_direction'
            cval = clean_thread_direction value
            acc2[key] = cval
          when 'type'
            cval = clean_type value
            acc2[key].concat cval
          when 'firing_mode'
            cval = clean_firing_mode value
            acc2[key].concat cval
          else
            acc2[key] = value
          end
        end
      end.values

      # Add a search corpus to optimize text query
      clean_products.each do |p|
        p['search_corpus'] = generate_search_corpus(
          p,
          %w[title gearbox magazine maker license motor speed system firing_mode description]
        )
      end

      File.write "#{DATA_FOLDER}/clean.json", clean_products.to_json

      clean_products
    end

    def scrap_product_details(urls)
      puts '[*] Scraping products details...'

      count = 0
      urls.map do |hsh|
        count += 1
        puts "[*] #{count} / #{urls.size} scrapped"

        doc = fetch_html hsh['url']

        # exclude out of stock
        unless doc.css('span.outofstock.onsale').empty?
          puts "[-] Out of stock product [#{hsh}]"
          next
        end

        details = doc.css('div.woocommerce_product_description').map(&:text).join(' ').strip
        desc = doc.css('div.woocommerce-product-details__short-description').text.strip
        specs = doc
                .css('table.woocommerce-product-attributes tr')
                .map { |tr| tr.css('th,td').map(&:text) }
                .map { |prop, value| [translate_prop(prop), value] }
                .select { |key, _value| allowed_keys.include? key.downcase }

        imgs = doc.css('div.slick-track img').flat_map { |i| i.attr('srcset').split.first }
        if imgs.blank?
          imgs = doc
                 .css('div.wl-single-slider img')
                 .flat_map { |i| i.attr('srcset')&.split }
                 .compact
                 .select { |url| url.start_with? 'http' }
        end

        record = {
          'id' => Digest::SHA256.hexdigest(hsh['url'])[0, 16],
          'url' => hsh['url'],
          'title' => doc.css('h1.product_title').first.text.strip,
          'price' => {
            'amount' => doc.css('div.tp-woo-price span.woocommerce-Price-amount.amount').last.text.strip.gsub(/[^0-9.]+/, '').to_f,
            'currency' => 'MXN',
          },
          'img' => imgs,
          'description' => [desc, details].join(' ').strip,
        }

        record.merge! Hash[specs] if specs

        record
      rescue StandardError => e
        binding.pry
      end.compact
    end

    def scrap_products_list
      puts '[*] Scraping product list...'

      payload = fetch_html 'https://airsoftzone.com.mx/wp-sitemap-posts-product-1.xml'
      payload.css('loc').map(&:text).map { |loc| { 'url' => loc } }
    end

    def scrap_section(section)
      urls = []
      payload = section

      loop do
        page_content = payload.dig 'content', 'rendered'
        doc = Nokogiri::HTML page_content

        page_urls = doc.css('.post-title a').map { |a| a.attr 'href' }

        urls.concat(page_urls.map { |url| { 'url' => url } })

        next_page = payload.dig '_links', 'up', 0, 'href'

        break if next_page.nil?

        payload = fetch_json next_page
      end

      urls
    end

    def fetch_html(url)
      body = fetch_page url
      Nokogiri::HTML body
    end

    def fetch_json(url)
      body = fetch_page url
      JSON.parse body
    end

    def fetch_page(url)
      puts "[*] Scrapping #{url}..."

      res = HTTParty.get url, headers: default_headers

      raise "Bad request! #{res.body}" if res.code != 200

      res.body
    end

    def default_headers
      {
        'User-Agent' => 'Mozilla/5.0 (X11; Linux x86_64; rv:142.0) Gecko/20100101 Firefox/142.0',
        'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language' => 'en-US,en;q=0.5',
        'Accept-Encoding' => 'gzip, deflate, br, zstd',
        'Connection' => 'keep-alive',
        'Cookie' => '_wcmpid=f1ac9ba4-8e3c-43ee-b688-4e6df7c43945; PHPSESSID=dac0a6160682c732ab5ad7cca2b0e76b; sbjs_migrations=1418474375998%3D1; sbjs_current_add=fd%3D2025-09-24%2021%3A36%3A30%7C%7C%7Cep%3Dhttps%3A%2F%2Fairsoftzone.com.mx%2F%7C%7C%7Crf%3Dhttps%3A%2F%2Fwww.google.com%2F; sbjs_first_add=fd%3D2025-09-17%2001%3A02%3A22%7C%7C%7Cep%3Dhttps%3A%2F%2Fairsoftzone.com.mx%2F%7C%7C%7Crf%3Dhttps%3A%2F%2Fduckduckgo.com%2F; sbjs_current=typ%3Dorganic%7C%7C%7Csrc%3Dgoogle%7C%7C%7Cmdm%3Dorganic%7C%7C%7Ccmp%3D%28none%29%7C%7C%7Ccnt%3D%28none%29%7C%7C%7Ctrm%3D%28none%29%7C%7C%7Cid%3D%28none%29%7C%7C%7Cplt%3D%28none%29%7C%7C%7Cfmt%3D%28none%29%7C%7C%7Ctct%3D%28none%29; sbjs_first=typ%3Dreferral%7C%7C%7Csrc%3Dduckduckgo.com%7C%7C%7Cmdm%3Dreferral%7C%7C%7Ccmp%3D%28none%29%7C%7C%7Ccnt%3D%2F%7C%7C%7Ctrm%3D%28none%29%7C%7C%7Cid%3D%28none%29%7C%7C%7Cplt%3D%28none%29%7C%7C%7Cfmt%3D%28none%29%7C%7C%7Ctct%3D%28none%29; sbjs_udata=vst%3D25%7C%7C%7Cuip%3D%28none%29%7C%7C%7Cuag%3DMozilla%2F5.0%20%28X11%3B%20Linux%20x86_64%3B%20rv%3A142.0%29%20Gecko%2F20100101%20Firefox%2F142.0; woolentor_already_views_count_product=a%3A39%3A%7Bi%3A1758071653%3Bi%3A8120%3Bi%3A1758071665%3Bi%3A8790%3Bi%3A1758072092%3Bi%3A7737%3Bi%3A1758072105%3Bi%3A6915%3Bi%3A1758073328%3Bi%3A8310%3Bi%3A1758073371%3Bi%3A10534%3Bi%3A1758073379%3Bi%3A5237%3Bi%3A1758588155%3Bi%3A3190%3Bi%3A1758588922%3Bi%3A10713%3Bi%3A1758588944%3Bi%3A13232%3Bi%3A1758589017%3Bi%3A10710%3Bi%3A1758589097%3Bi%3A4008%3Bi%3A1758589229%3Bi%3A6539%3Bi%3A1758591241%3Bi%3A2105%3Bi%3A1758591273%3Bi%3A3969%3Bi%3A1758591639%3Bi%3A6571%3Bi%3A1758591788%3Bi%3A7964%3Bi%3A1758596589%3Bi%3A10617%3Bi%3A1758596639%3Bi%3A10612%3Bi%3A1758636934%3Bi%3A2568%3Bi%3A1758648647%3Bi%3A4360%3Bi%3A1758682346%3Bi%3A12617%3Bi%3A1758682368%3Bi%3A11562%3Bi%3A1758683234%3Bi%3A11624%3Bi%3A1758683440%3Bi%3A1917%3Bi%3A1758683621%3Bi%3A11622%3Bi%3A1758683645%3Bi%3A571%3Bi%3A1758684015%3Bi%3A11529%3Bi%3A1759296317%3Bi%3A7686%3Bi%3A1759296446%3Bi%3A8418%3Bi%3A1759296590%3Bi%3A1802%3Bi%3A1759296667%3Bi%3A10961%3Bi%3A1759296683%3Bi%3A5298%3Bi%3A1760987950%3Bi%3A500%3Bi%3A1760987972%3Bi%3A5807%3Bi%3A1761841909%3Bi%3A13300%3Bi%3A1761842175%3Bi%3A4355%3Bi%3A1761928664%3Bi%3A11538%3Bi%3A1763675757%3Bi%3A9454%3B%7D; woolentor_viewed_products_list=a%3A1%3A%7Bi%3A1763675757%3Bi%3A9454%3B%7D; _lscache_vary=65ed135a2d24664935e20f7587e8ddc3; sbjs_session=pgs%3D13%7C%7C%7Ccpg%3Dhttps%3A%2F%2Fairsoftzone.com.mx%2Fproductos-de-airsoft%2Fhttps-airsoftzone-com-mx-productos-de-airsoft-https-airsoftzone-com-mx-productos-de-airsoft-replicas-de-rifles-para-airsoft%2Freplicas-de-airsoft-tipo-asalto%2F',
        'Upgrade-Insecure-Requests' => '1',
        'Sec-Fetch-Dest' => 'document',
        'Sec-Fetch-Mode' => 'navigate',
        'Sec-Fetch-Site' => 'cross-site',
        'Priority' => 'u=0',
      }
    end

    def allowed_keys
      @allowed_keys ||= %w[
        battery
        bb
        capacity
        charger
        color
        description
        diameter
        dimensions
        fire_rate
        firing_mode
        fps_range
        gas
        gearbox
        hardness
        hop_up
        id
        img
        inner_barrel
        length
        magazine
        magnification
        maker
        materials
        mosfet
        motor
        outer_barrel
        package_contents
        performance
        power
        price
        range
        speed
        system
        thread_direction
        title
        trigger
        type
        url
        voltage
        weight
      ]
    end

    def translate_prop(value)
      props_dict.fetch clean_prop_name(value), value
    end

    def props_dict
      @props_dict ||= {
        'barril_interior' => 'inner_barrel',
        'batera' => 'battery',
        'caja_gearbox' => 'gearbox',
        'caon_interno' => 'inner_barrel',
        'capacidad' => 'capacity',
        'capacidad_cargador' => 'capacity',
        'cargador' => 'magazine',
        'color' => 'color',
        'dimensiones' => 'dimensions',
        'energa' => 'system',
        'fabricante' => 'maker',
        'gas' => 'gas',
        'gatillo_electrnico' => 'trigger',
        'gearbox' => 'gearbox',
        'hop_up' => 'hop_up',
        'hopup' => 'hop_up',
        'incluye' => 'package_contents',
        'inner_barrel' => 'inner_barrel',
        'largo' => 'length',
        'longitud' => 'length',
        'longitud_can_interno' => 'inner_barrel',
        'longitud_mxima' => 'length',
        'modo_disparo' => 'firing_mode',
        'modos_disparo' => 'firing_mode',
        'modos_fuego' => 'firing_mode',
        'mosfet' => 'mosfet',
        'motor' => 'motor',
        'peso' => 'weight',
        'potencia' => 'power',
        'rango_fps' => 'fps_range',
        'rendimiento' => 'performance',
        'rondas_segundo' => 'fire_rate',
        'rosca' => 'thread_direction',
        'sistema' => 'system',
        'tipo_gas' => 'gas',
        'tipo_rosca' => 'thread_direction',
        'tiros_segundo' => 'fire_rate',
        'velocidad_salida' => 'speed',
      }
    end

    def clean_title(value)
      value
    end

    # veta airsoft
    def clean_battery(value)
      capacity = value
                 .scan(/([\d,.]+\s*V\s*(\d+\s*mAh)?)/i)
                 .map(&:first)
                 .compact
                 .uniq
                 .map { |v| v.strip.tr 'v,', 'V.' }

      type = value
             .scan(/(PEQ|LiPo|NiMH|tubo|palo|stick|barra|lapiz|Butterfly|mariposa)/i)
             .map(&:first)
             .compact
             .uniq
             .map(&:strip)

      type = type.map do |t|
        clean = 'PEQ' if t.downcase == 'peq'
        clean = 'LiPo' if t.downcase == 'lipo'
        clean = 'NiMH' if t.downcase == 'nimh'

        clean
      end.compact.uniq

      return [] if capacity.empty? && type.empty?

      [{
        capacity: capacity,
        type: type,
      }]
    end

    def clean_fps_range(value)
      value
    end

    def clean_gearbox(value)
      value
    end

    def clean_hop_up(value)
      value
    end

    def clean_inner_barrel(value)
      value
    end

    def clean_magazine(value)
      value
    end

    def clean_maker(value)
      [value]
    end

    def clean_motor(value)
      value
    end

    def clean_price(value)
      value
    end

    def clean_speed(value)
      value
    end

    def clean_system(value)
      value
    end

    def clean_thread_direction(value)
      value
    end

    def clean_type(value)
      [value]
    end

    def clean_fire_rate(value)
      return [] if value.blank?

      value.split(',').map(&:strip)
    end

    def clean_firing_mode(value)
      return [] if value.blank?

      res = []
      res << 'safety' if value.match?(/seguridad/i)
      res << 'semi' if value.match?(/semi/i)
      res << 'full' if value.match?(/(full|complet)/i)

      res
    end
  end
end

Tactishop.start ARGV
