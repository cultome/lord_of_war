#!/usr/bin/env ruby

$LOAD_PATH.unshift './lib'

require 'brotli'
require 'csv'
require 'httparty'
require 'json'
require 'lord_of_war'
require 'lord_of_war/utils'
require 'nokogiri'
require 'pry'
require 'securerandom'
require 'set'
require 'sqlite3'
require 'thor'

class VetaAirsoft < Thor
  include LordOfWar::Utils

  DATA_FOLDER = "#{File.dirname __FILE__}/../data/vetaairsoft"

  BASE_URL = 'https://vetaairsoft.com'

  SECTIONS = [
    '/accesorios',
    '/accesorios1',
    '/caja-sorpresa',
    '/camping',
    '/consumibles',
    '/miras-tacticas',
    '/mochilas',
    '/pouches',
    '/protecciones',
    '/pulseras',
    '/replicas',
    '/ropa',
    '/seguridad',
    '/torniquetes',
  ]

  STAGES = %w[urls details clean audit]

  desc 'upload FILE', 'Load data in DB'
  def upload(file)
    records = JSON.parse File.read(file)

    db = SQLite3::Database.new 'low.db'
    db.results_as_hash = true

    ins_products_sql = <<~SQL
      INSERT INTO products(id, search_corpus, title, url, description, price, capacity_id, category_id, fps_range_id, gearbox_id, hop_up_id, inner_barrel_id, magazine_id, motor_id, outer_barrel_id, speed_id, system_id, thread_direction_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
      RETURNING id
    SQL

    upd_products_sql = <<~SQL
      UPDATE products SET
      search_corpus = $2, title = $3, url = $4, description = $5, price = $6, capacity_id = $7, category_id = $8,#{" "}
      fps_range_id = $9, gearbox_id = $10, hop_up_id = $11, inner_barrel_id = $12, magazine_id = $13, motor_id = $14,#{" "}
      outer_barrel_id = $15, speed_id = $16, system_id = $17, thread_direction_id = $18
      WHERE id = $1
      RETURNING id
    SQL

    count = 0
    records.each do |rec|
      count += 1
      print "  #{count} / #{records.size} ...      \r"

      capacity_id = fetch_or_create 'capacities', rec['capacity'], db
      category_id = fetch_or_create 'categories', rec['category'], db
      fps_range_id = fetch_or_create 'fps_ranges', rec['fps_range'], db
      gearbox_id = fetch_or_create 'gearboxes', rec['gearbox'], db
      hop_up_id = fetch_or_create 'hop_ups', rec['hop_up'], db
      inner_barrel_id = fetch_or_create 'inner_barrels', rec['inner_barrel'], db
      magazine_id = fetch_or_create 'magazines', rec['magazine'], db
      motor_id = fetch_or_create 'motors', rec['motor'], db
      outer_barrel_id = fetch_or_create 'outer_barrels', rec['outer_barrel'], db
      speed_id = fetch_or_create 'speeds', rec['speed'], db
      system_id = fetch_or_create 'systems', rec['system'], db
      thread_direction_id = fetch_or_create 'thread_directions', rec['thread_direction'], db

      is_new_product = db
                       .execute('SELECT id FROM products WHERE id = $1', [rec['id']])
                       .map { |p| p['id'] }
                       .first
                       .nil?

      product_id = if is_new_product
                     db.execute(
                       ins_products_sql,
                       [
                         rec['id'],
                         rec['search_corpus'],
                         rec['title'],
                         rec['url'],
                         rec['description'],
                         rec.dig('price', 'amount'),
                         capacity_id,
                         category_id,
                         fps_range_id,
                         gearbox_id,
                         hop_up_id,
                         inner_barrel_id,
                         magazine_id,
                         motor_id,
                         outer_barrel_id,
                         speed_id,
                         system_id,
                         thread_direction_id,
                       ]
                     ).map { |row| row['id'] }.first
                   else
                     db.execute(
                       upd_products_sql,
                       [
                         rec['id'],
                         rec['search_corpus'],
                         rec['title'],
                         rec['url'],
                         rec['description'],
                         rec.dig('price', 'amount'),
                         capacity_id,
                         category_id,
                         fps_range_id,
                         gearbox_id,
                         hop_up_id,
                         inner_barrel_id,
                         magazine_id,
                         motor_id,
                         outer_barrel_id,
                         speed_id,
                         system_id,
                         thread_direction_id,
                       ]
                     ).map { |row| row['id'] }.first
                   end

      (rec['battery'] || []).each do |val|
        val['capacity'].product(val['type']).each do |cap, tp|
          calc_val = "#{cap} #{tp}"

          battery_id = fetch_or_create 'batteries', calc_val, db
          create_product_relation_if_required 'products_batteries', 'battery_id', product_id, battery_id, db
        end
      end

      (rec['firing_mode'] || []).each do |val|
        firing_mode_id = fetch_or_create 'firing_modes', val, db
        create_product_relation_if_required 'products_firing_modes', 'firing_mode_id', product_id, firing_mode_id, db
      end

      (rec['img'] || []).each do |val|
        img_id = fetch_or_create 'imgs', val, db
        create_product_relation_if_required 'products_imgs', 'img_id', product_id, img_id, db
      end

      (rec['license'] || []).each do |val|
        license_id = fetch_or_create 'licenses', val, db
        create_product_relation_if_required 'products_licenses', 'license_id', product_id, license_id, db
      end

      (rec['maker'] || []).each do |val|
        maker_id = fetch_or_create 'makers', val, db
        create_product_relation_if_required 'products_makers', 'maker_id', product_id, maker_id, db
      end

      (rec['type'] || []).each do |val|
        type_id = fetch_or_create 'types', val, db
        create_product_relation_if_required 'products_types', 'type_id', product_id, type_id, db
      end
    rescue StandardError => e
      binding.pry
    end
  end

  desc 'scrap', 'Scrap site'
  option :from, type: :string, default: 'urls', desc: "Start scraping from a given stage. Valid options: #{STAGES.join ", "}"
  option :audit, type: :boolean, deafult: false
  def scrap
    initial_stage = STAGES.find_index options[:from]

    urls = if initial_stage > 0 # urls
             puts '[*] Loading URLs from cache...'
             JSON.parse File.read("#{DATA_FOLDER}/product_urls.json")
           else
             urls = scrap_products_list
             File.write "#{DATA_FOLDER}/product_urls.json", urls.to_json

             urls
           end

    products = if initial_stage > 1 # details
                 puts '[*] Loading product details from cache...'
                 JSON.parse File.read("#{DATA_FOLDER}/product_details.json")
               else
                 products = scrap_product_details urls
                 File.write "#{DATA_FOLDER}/product_details.json", products.to_json

                 products
               end

    clean_products = if initial_stage > 2 # clean
                       puts '[*] Loading clean products from cache...'
                       JSON.parse File.read("#{DATA_FOLDER}/products_clean.json")
                     else
                       clean_products = clean_records products
                       File.write "#{DATA_FOLDER}/products_clean.json", clean_products.to_json

                       clean_products
                     end

    audit_props DATA_FOLDER, clean_products if options[:audit]

    puts '[+] Done!'
  end

  no_commands do
    def clean_records(products)
      error_reports = {}

      clean_products = products.each_with_object({}) do |prod, acc|
        acc[prod['url']] = prod.each_with_object(Hash.new { |h, k| h[k] = [] }) do |(key, value), acc2|
          key = props_dict.fetch clean_prop_name(key), key

          unless allowed_keys.include? key
            unless error_reports.key? key
              error_reports[key] = true
              puts "[-] Key [#{key}] not allowed"
            end
            next
          end

          case key
          when 'title'
            acc2.merge! extract_title_info(value)
            cval = clean_title value
            acc2[key] = cval
          when 'battery'
            cval = clean_battery value
            acc2[key].concat cval
          when 'fps_range'
            cval = clean_fps_range value
            acc2[key] = cval
          when 'gearbox'
            cval = clean_gearbox value
            acc2[key] = cval
          when 'hop_up'
            cval = clean_hop_up value
            acc2[key] = cval
          when 'inner_barrel'
            cval = clean_inner_barrel value
            acc2[key] = cval
          when 'magazine'
            cval = clean_magazine value
            acc2[key] = cval
          when 'maker'
            cval = clean_maker value
            acc2[key].concat cval
          when 'motor'
            cval = clean_motor value
            acc2[key] = cval
          when 'price'
            cval = clean_price value
            acc2[key] = cval
          when 'speed'
            cval = clean_speed value
            acc2[key] = cval
          when 'system'
            cval = clean_system value
            acc2[key] = cval
          when 'thread_direction'
            cval = clean_thread_direction value
            acc2[key] = cval
          when 'type'
            cval = clean_type value
            acc2[key].concat cval
          when 'firing_mode'
            cval = clean_firing_mode value
            acc2[key].concat cval
          when 'url'
            acc2[key] = value
            acc2['id'] = Digest::SHA256.hexdigest(value)[0, 16]
          else
            acc2[key] = value
          end
        end
      end.values

      # Add a search corpus to optimize text query
      clean_products.each do |p|
        search_corpus = p
                        .slice(*%w[title gearbox magazine maker license motor speed system firing_mode description])
                        .reduce('') do |acc, val|
          if val.is_a? String
            acc + " #{val}"
          elsif val.is_a? Array
            acc + " #{val.join " "}"
          elsif val.is_a? Hash
            acc + " #{val.values.join " "}"
          end
        end

        p['search_corpus'] = search_corpus.downcase.tr 'áéíóú', 'aeiou'
      end

      File.write "#{DATA_FOLDER}/products_clean.json", clean_products.to_json

      clean_products
    end

    def scrap_product_details(urls)
      puts '[*] Scraping products details...'

      count = 0
      urls.map do |url|
        count += 1
        doc = fetch_html url

        record = {
          url: url,
          title: doc.css('h1#product-name').text,
          price: {
            amount: doc.css('h4#price_display').text.strip.gsub(/[^0-9.]+/, '').to_f,
            currency: 'MXN',
          },
          img: doc.css('div.swiper-wrapper.align-items-center img')
                  .map { |i| i['data-srcset'] }
                  .compact
                  .map { |url| url.split(', ').map(&:split).map(&:first) }
                  .flatten
                  .map { |url| "https:#{url}" },
        }

        feats = doc.css 'div.product-description.user-content ul.productfeatures li'

        if feats.empty?
          desc = doc.css('div.product-description.user-content p').map(&:text).join.gsub("\r\n", ' ')

          record.merge! description: desc
        else
          texts = feats.flat_map { |e| e.css('strong,span') }.map(&:text)

          specs = {}
          desc = []
          idx = 0
          loop do
            break if idx >= texts.size

            if texts[idx].end_with? ':'
              unless texts[idx + 1].strip.end_with? ':'
                prop = texts[idx][0..-2]
                specs[props_dict.fetch(prop, prop)] = texts[idx + 1].gsub(' ', ' ').strip
                idx += 1
              end
            else
              desc << texts[idx]
            end

            idx += 1
          end
          record.merge!(description: desc.join, **specs)
        end
        puts "[*] #{count} / #{urls.size} scrapped"
      rescue StandardError => e
        puts e.message
        binding.pry
      end
    end

    def scrap_products_list
      puts '[*] Scraping product list...'

      link_style = 'div.js-item-description-container.item-description-container.p-2.p-md-4.shadow-none.position-absolute.w-100.transition-soft a'
      urls = []

      SECTIONS.each do |section|
        page = 1

        loop do
          payload = fetch_json "#{BASE_URL}#{section}/page/#{page}/?results_only=true&limit=100&theme=cubo"
          doc = Nokogiri::HTML payload['html']
          urls.concat doc.css(link_style).map { |l| l['href'] }.uniq

          break unless payload['has_next']

          page += 1
        end
      rescue StandardError => e
        puts "[-] Error scraping product list: #{e.message}"
        binding.pry
      end

      urls
    end

    def fetch_html(url)
      body = fetch_page url
      Nokogiri::HTML body
    end

    def fetch_json(url)
      body = fetch_page url
      JSON.parse body
    end

    def fetch_page(url)
      puts "[*] Scrapping #{url}..."

      res = HTTParty.get url, headers: default_headers

      raise "Bad request! #{res.body}" if res.code != 200

      res.body
    end

    def default_headers
      {
        'User-Agent' => 'Mozilla/5.0 (X11; Linux x86_64; rv:142.0) Gecko/20100101 Firefox/142.0',
        'Accept' => 'image/webp, application/json',
        'Accept-Language' => 'en-US,en;q=0.5',
        'Accept-Encoding' => 'gzip, deflate, br, zstd',
        'Referer' => 'https://vetaairsoft.com/accesorios1/?mpage=4',
        'X-Requested-With' => 'XMLHttpRequest',
        'Connection' => 'keep-alive',
        'Cookie' => '__cf_bm=mtmwoOFfSm3PFYshoJ3eBaNe6LTCl1ba.UYhMUmQ4L4-1762319728-1.0.1.1-NnLZ8QH9RXpBrLp.kmePDudWfi7Bn1fq8DjU_kdx3XZC34mkyoQw3kQfHrhMV3DPdqNvOKWSt.rUImWJZtqZGsMMomS82rSPGH42ubOhogI; _gcl_au=1.1.833731081.1762318566; newsletter-popup=1; _ga=GA1.2.1714847667.1762318566; _gid=GA1.2.2142166821.1762318566; tn_track=8b6529726fc3324ec5113e896f80b5e5c14526c7%7E3a3eef2c980db2e8d9f9f85bf37f9397b01e5308; x-rand-user=7ec4bfd161aa5e499acde766c63c8a862511a95e%7E3866; tn_tracksession=2675e7b2199cf16d65131eb172883b40b02dc132%7E17dd56264d2a50f92605c7b008499268904f67f5; store_session_payload_1981503=a5be91efb6826f819cb78cf9600339a1cbde7a7b%7EeyJpdiI6IlpianNWbnRjUzZySDVuWHdiOU9OWFE9PSIsInZhbHVlIjoidENnYllKemNXdUt6OU5jNnpWM3JYR0RYTXIvVng4NkRGdmtXTUJCeEZJV3p5eHcrRGM1Ry8vVWJTMy9xclBEbm9zMmorV0VRR1RMdGYrek92dUttcjUySFk4MVNBS3cxUm9rQUN4MGxsSHovaGV6K2x6SWhldDJNQys5YjIvYXBUYWkrZ1NmWDJpR2h1cEZXSXR6Qm9ad0liUHdqczBUS3pOajRuN05MY3kwMWE5RFNqWmFUbTlFYStxeko5UGFqbDhtR1FsSTQvSzUwL05IdU1RMzNKMzNPL0l3cGpsSWhOQnlsMzlreHV3emxueWRQZndsdDlpTEJPcGs1eUFIZ2txZ0Qwa2lUN1pLem95SnZMSkNvelNsMWtQRktsNnJZV2ZjVnFXc2JIKzlxU1A2a2YxYWwwSHN6QUJPRm0xZklEcTFaanpGeG80Y3l1SFFiRS9nWFhnPT0iLCJtYWMiOiJkY2YxMTY1NjE4OTVmNDIwZDU5NzdiM2Y1ZTY3MzIxNTM2MTUwMzBhNmUyZDNmNWNkMWJlNjU4OGE4MjQ1YThlIn0%3D; store_login_session=3be5fcabf721a65238e6e7cedb6c0ad66268ab5f%7Eae4c807e0e484a5cbdce427c3fee3b21297a94d1addc2ce5d49f0d0778c5be8e; _ga_Y01EEPH4TK=GS2.2.s1762318566$o1$g1$t1762320169$j60$l0$h0; _fbp=fb.1.1762318566702.154717759849449291; wpnViewcount=13; TPIDC=hiw3sp-9cwnmtde1-ujhdfbn2t1ar9is5y-eqpdmi48unhwfg-al1-wtc; cwdcc=false; cus=false; wallet-cross-store-impossible=false; _wpnlvusw=1; wpnLastDenial=1762318693034; cookie_consent=1; _wpn_cotpc=1; sdtpc=1',
        'Sec-Fetch-Dest' => 'empty',
        'Sec-Fetch-Mode' => 'cors',
        'Sec-Fetch-Site' => 'same-origin',
        'Priority' => 'u=4',
        'TE' => 'trailers',
      }
    end

    def allowed_keys
      @allowed_keys ||= %w[
        battery
        bb
        capacity
        charger
        description
        diameter
        dimensions
        fire_rate
        firing_mode
        fps_range
        gas
        gearbox
        hardness
        hop_up
        img
        inner_barrel
        magazine
        magnification
        maker
        materials
        motor
        outer_barrel
        price
        range
        speed
        system
        thread_direction
        title
        type
        url
        voltage
      ]
    end

    def props_dict
      @props_dict ||= {
        'Altura' => 'height',
        'Ancho' => 'width',
        'Batería' => 'battery',
        'Caja de cambios' => 'gearbox',
        'Capacidad del cargador' => 'capacity',
        'Cargador' => 'magazine',
        'Cañón exterior' => 'outer_barrel',
        'Cañón interior' => 'inner_barrel',
        'Cañón interno' => 'inner_barrel',
        'Cilindro interno' => 'inner_barrel',
        'Dirección de la rosca' => 'thread_direction',
        'Dirección de rosca' => 'thread_direction',
        'El paquete incluye' => 'package_contents',
        'Español : Longitud' => 'length',
        'FPS' => 'fps_range',
        'Fabricante' => 'maker',
        'Hopup' => 'hop_up',
        'Longitud' => 'length',
        'Longitud del cañón' => 'length',
        'Modo de disparo' => 'firing_mode',
        'Modo de disparo ' => 'firing_mode',
        'Modos de disparo' => 'firing_mode',
        'Modos de disparo preprogramados' => 'firing_mode',
        'Motor' => 'motor',
        'Peso' => 'weight',
        'Peso (con cargador)' => 'weight',
        'Peso (con cargador) /o Cargador)' => 'weight',
        'Peso total' => 'weight',
        'Rango de FPS' => 'fps_range',
        'Rondas por segundo' => 'fire_rate',
        'Sistema de seguridad' => 'system',
        'Tipo de gas' => 'type',
        'Velocidad de salida' => 'speed',
        'Velocidad inicial' => 'speed',
        'batería de seguridad' => 'battery',
        'guardamanos ajustable Longitud' => 'length',
        'incluye' => 'package_contents',
        'sistema de acción del cerrojo' => 'system',
        # 'description' => '',
        # 'img' => '',
        # 'price' => '',
        # 'title' => '',
        # 'url' => '',
      }
    end

    def clean_title(value)
      value
    end

    # veta airsoft
    def clean_battery(value)
      capacity = value
                 .scan(/([\d,.]+\s*V\s*(\d+\s*mAh)?)/i)
                 .map(&:first)
                 .compact
                 .uniq
                 .map { |v| v.strip.tr 'v,', 'V.' }

      type = value
             .scan(/(PEQ|LiPo|NiMH|tubo|palo|stick|barra|lapiz|Butterfly|mariposa)/i)
             .map(&:first)
             .compact
             .uniq
             .map(&:strip)

      type = type.map do |t|
        clean = 'PEQ' if t.downcase == 'peq'
        clean = 'LiPo' if t.downcase == 'lipo'
        clean = 'NiMH' if t.downcase == 'nimh'

        clean
      end.compact.uniq

      return [] if capacity.empty? && amount.empty? && type.empty?

      [{
        capacity: capacity,
        type: type,
      }]
    end

    def clean_fps_range(value)
      value
    end

    def clean_gearbox(value)
      value
    end

    def clean_hop_up(value)
      value
    end

    def clean_inner_barrel(value)
      value
    end

    def clean_magazine(value)
      value
    end

    def clean_maker(value)
      [value]
    end

    def clean_motor(value)
      value
    end

    def clean_price(value)
      value
    end

    def clean_speed(value)
      value
    end

    def clean_system(value)
      value
    end

    def clean_thread_direction(value)
      value
    end

    def clean_type(value)
      [value]
    end

    def clean_fire_rate(value)
      return [] if value.blank?

      value.split(',').map(&:strip)
    end

    def clean_firing_mode(value)
      return [] if value.blank?

      res = []
      res << 'safety' if value.match?(/seguridad/i)
      res << 'semi' if value.match?(/semi/i)
      res << 'full' if value.match?(/(full|complet)/i)

      res
    end
  end
end

VetaAirsoft.start ARGV
