#!/usr/bin/env ruby

$LOAD_PATH.unshift './lib'

require 'brotli'
require 'csv'
require 'httparty'
require 'json'
require 'lord_of_war/monkeypatch'
require 'nokogiri'
require 'pry'
require 'securerandom'
require 'set'
require 'sqlite3'
require 'thor'
require_relative 'utils'

class Tactishop < Thor
  include Utils

  DATA_FOLDER = "#{File.dirname __FILE__}/../data/tactishop"

  BASE_URL = 'https://www.tactishop.mx'

  SECTIONS = [
    '/categorias/replicas',
    '/categorias/equipamiento-tactico',
    '/categorias/partes-y-accesorios/cargadores',
    '/categorias/partes-y-accesorios/bb-y-gas',
    '/categorias/partes-y-accesorios/baterias',
    '/categorias/novritsch/equipamiento-novritsch/camuflaje-novritsch',
  ]

  STAGES = %w[urls details clean audit]

  desc 'scrap', 'Scrap site'
  option :from, type: :string, default: 'urls', desc: "Start scraping from a given stage. Valid options: #{STAGES.join ", "}"
  option :audit, type: :boolean, deafult: false
  def scrap
    initial_stage = STAGES.find_index options[:from]

    urls = if initial_stage > 0 # urls
             puts '[*] Loading URLs from cache...'
             JSON.parse File.read("#{DATA_FOLDER}/product_urls.json")
           else
             urls = scrap_products_list
             File.write "#{DATA_FOLDER}/product_urls.json", urls.to_json

             existing = {}
             urls.select do |hsh|
               if existing.key? hsh['url']
                 false
               else
                 existing[hsh['url']] = true
                 true
               end
             end
           end

    products = if initial_stage > 1 # details
                 puts '[*] Loading product details from cache...'
                 JSON.parse File.read("#{DATA_FOLDER}/product_details.json")
               else
                 products = scrap_product_details urls
                 File.write "#{DATA_FOLDER}/product_details.json", products.to_json

                 products
               end

    clean_products = if initial_stage > 2 # clean
                       puts '[*] Loading clean products from cache...'
                       JSON.parse File.read("#{DATA_FOLDER}/clean.json")
                     else
                       clean_products = clean_records products
                       File.write "#{DATA_FOLDER}/clean.json", clean_products.to_json

                       clean_products
                     end

    audit_props DATA_FOLDER, clean_products if options[:audit]

    puts '[+] Done!'
  end

  desc 'upload FILE', 'Load data in DB'
  def upload(file)
    records = JSON.parse File.read(file)

    db = SQLite3::Database.new 'low.db'
    db.results_as_hash = true

    ins_products_sql = <<~SQL
      INSERT INTO products(id, search_corpus, title, url, description, price, capacity_id, category_id, fps_range_id, gearbox_id, hop_up_id, inner_barrel_id, magazine_id, motor_id, outer_barrel_id, speed_id, system_id, thread_direction_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
      RETURNING id
    SQL

    upd_products_sql = <<~SQL
      UPDATE products SET
      search_corpus = $2, title = $3, url = $4, description = $5, price = $6, capacity_id = $7, category_id = $8,#{" "}
      fps_range_id = $9, gearbox_id = $10, hop_up_id = $11, inner_barrel_id = $12, magazine_id = $13, motor_id = $14,#{" "}
      outer_barrel_id = $15, speed_id = $16, system_id = $17, thread_direction_id = $18
      WHERE id = $1
      RETURNING id
    SQL

    count = 0
    records.each do |rec|
      count += 1
      print "  #{count} / #{records.size} ...      \r"

      capacity_id = fetch_or_create 'capacities', rec['capacity'], db
      category_id = fetch_or_create 'categories', rec['category'], db
      fps_range_id = fetch_or_create 'fps_ranges', rec['fps_range'], db
      gearbox_id = fetch_or_create 'gearboxes', rec['gearbox'], db
      hop_up_id = fetch_or_create 'hop_ups', rec['hop_up'], db
      inner_barrel_id = fetch_or_create 'inner_barrels', rec['inner_barrel'], db
      magazine_id = fetch_or_create 'magazines', rec['magazine'], db
      motor_id = fetch_or_create 'motors', rec['motor'], db
      outer_barrel_id = fetch_or_create 'outer_barrels', rec['outer_barrel'], db
      speed_id = fetch_or_create 'speeds', rec['speed'], db
      system_id = fetch_or_create 'systems', rec['system'], db
      thread_direction_id = fetch_or_create 'thread_directions', rec['thread_direction'], db

      is_new_product = db
                       .execute('SELECT id FROM products WHERE id = $1', [rec['id']])
                       .map { |p| p['id'] }
                       .first
                       .nil?

      product_id = if is_new_product
                     db.execute(
                       ins_products_sql,
                       [
                         rec['id'],
                         rec['search_corpus'],
                         rec['title'],
                         rec['url'],
                         rec['description'],
                         rec.dig('price', 'amount'),
                         capacity_id,
                         category_id,
                         fps_range_id,
                         gearbox_id,
                         hop_up_id,
                         inner_barrel_id,
                         magazine_id,
                         motor_id,
                         outer_barrel_id,
                         speed_id,
                         system_id,
                         thread_direction_id,
                       ]
                     ).map { |row| row['id'] }.first
                   else
                     db.execute(
                       upd_products_sql,
                       [
                         rec['search_corpus'],
                         rec['title'],
                         rec['url'],
                         rec['description'],
                         rec.dig('price', 'amount'),
                         capacity_id,
                         category_id,
                         fps_range_id,
                         gearbox_id,
                         hop_up_id,
                         inner_barrel_id,
                         magazine_id,
                         motor_id,
                         outer_barrel_id,
                         speed_id,
                         system_id,
                         thread_direction_id,
                         rec['id'],
                       ]
                     ).map { |row| row['id'] }.first
                   end

      (rec['battery'] || []).each do |val|
        val['capacity'].product(val['type']).each do |cap, tp|
          calc_val = "#{cap} #{tp}"

          battery_id = fetch_or_create 'batteries', calc_val, db
          create_product_relation_if_required 'products_batteries', 'battery_id', product_id, battery_id, db
        end
      end

      (rec['firing_mode'] || []).each do |val|
        firing_mode_id = fetch_or_create 'firing_modes', val, db
        create_product_relation_if_required 'products_firing_modes', 'firing_mode_id', product_id, firing_mode_id, db
      end

      (rec['img'] || []).each do |val|
        img_id = fetch_or_create 'imgs', val, db
        create_product_relation_if_required 'products_imgs', 'img_id', product_id, img_id, db
      end

      (rec['license'] || []).each do |val|
        license_id = fetch_or_create 'licenses', val, db
        create_product_relation_if_required 'products_licenses', 'license_id', product_id, license_id, db
      end

      (rec['maker'] || []).each do |val|
        maker_id = fetch_or_create 'makers', val, db
        create_product_relation_if_required 'products_makers', 'maker_id', product_id, maker_id, db
      end

      (rec['type'] || []).each do |val|
        type_id = fetch_or_create 'types', val, db
        create_product_relation_if_required 'products_types', 'type_id', product_id, type_id, db
      end
    rescue StandardError => e
      binding.pry
    end
  end

  no_commands do
    def overwrite_category_by_url!(acc, prod)
      if prod['section'] == '/categorias/replicas'
        acc['category'] = 'replica'
      elsif prod['section'] == '/categorias/equipamiento-tactico'
        acc['category'] = 'gear'
      elsif prod['section'] == '/categorias/partes-y-accesorios/cargadores'
        acc['category'] = 'accessories'
      elsif prod['section'] == '/categorias/partes-y-accesorios/bb-y-gas'
        acc['category'] = 'consumable'
      elsif prod['section'] == '/categorias/partes-y-accesorios/baterias'
        acc['category'] = 'accessories'
      elsif prod['section'] == '/categorias/novritsch/equipamiento-novritsch/camuflaje-novritsch'
        acc['category'] = 'gear'
      end
    rescue StandardError
      puts "Unable to overwrite category for [#{prod.inspect}]"
    end

    def clean_records(products)
      error_reports = {}

      clean_products = products.each_with_object({}) do |prod, acc|
        acc[prod['url']] = prod.each_with_object(Hash.new { |h, k| h[k] = [] }) do |(key, value), acc2|
          key = props_dict.fetch clean_prop_name(key), key

          unless allowed_keys.include? key
            unless error_reports.key? key
              error_reports[key] = true
              puts "[-] Key [#{key}] not allowed"
            end
            next
          end

          case key
          when 'title'
            acc2.merge! extract_title_info(value)
            overwrite_category_by_url! acc2, prod
            cval = clean_title value
            acc2[key] = cval
          when 'battery'
            cval = clean_battery value
            acc2[key].concat cval
          when 'fps_range'
            cval = clean_fps_range value
            acc2[key] = cval
          when 'gearbox'
            cval = clean_gearbox value
            acc2[key] = cval
          when 'hop_up'
            cval = clean_hop_up value
            acc2[key] = cval
          when 'inner_barrel'
            cval = clean_inner_barrel value
            acc2[key] = cval
          when 'magazine'
            cval = clean_magazine value
            acc2[key] = cval
          when 'maker'
            cval = clean_maker value
            acc2[key].concat cval
          when 'motor'
            cval = clean_motor value
            acc2[key] = cval
          when 'price'
            cval = clean_price value
            acc2[key] = cval
          when 'speed'
            cval = clean_speed value
            acc2[key] = cval
          when 'system'
            cval = clean_system value
            acc2[key] = cval
          when 'thread_direction'
            cval = clean_thread_direction value
            acc2[key] = cval
          when 'type'
            cval = clean_type value
            acc2[key].concat cval
          when 'firing_mode'
            cval = clean_firing_mode value
            acc2[key].concat cval
          else
            acc2[key] = value
          end
        end
      end.values

      # Add a search corpus to optimize text query
      clean_products.each do |p|
        p['search_corpus'] = generate_search_corpus(
          p,
          %w[title gearbox magazine maker license motor speed system firing_mode description]
        )
      end

      File.write "#{DATA_FOLDER}/clean.json", clean_products.to_json

      clean_products
    end

    def scrap_product_details(urls)
      puts '[*] Scraping products details...'

      count = 0
      urls.map do |hsh|
        count += 1
        puts "[*] #{count} / #{urls.size} scrapped"

        doc = fetch_html hsh['url']

        details = doc.css('div.summary-inner.wd-set-mb').first
        desc = doc.css('div.woocommerce-product-details__short-description').text
        feats = doc.css('div.woocommerce-product-details__short-description li').map(&:text).join(' ')

        all_specs = doc
                    .css('div#tab-description p')
                    .flat_map { |p| p.text.split("\n") }
                    .select { |txt| txt.include? ': ' }
                    .map { |txt| txt.split(': ') }
                    .map { |prop, value| [props_dict.fetch(clean_prop_name(prop), prop), value] }

        specs = all_specs.select { |key, _value| allowed_keys.include? key.downcase }
        non_specs = all_specs.reject { |key, _value| allowed_keys.include? key.downcase }

        other_texts = doc
                      .css('div#tab-description p')
                      .flat_map { |p| p.text.split("\n") }
                      .reject { |txt| txt.include? ':' }

        desc = [
          desc,
          feats,
          other_texts.join(' '),
          non_specs.map { |s| s.join(': ') }.join('. '),
        ].map(&:strip).join(' ').strip

        imgs = doc.css('div.wd-carousel img').flat_map { |i| i.attr('data-srcset').split.first }
        imgs = doc.css('img.wp-post-image').map { |i| i.attr 'src' } if imgs.empty?

        record = {
          'id' => Digest::SHA256.hexdigest(hsh['url'])[0, 16],
          'url' => hsh['url'],
          'section' => hsh['section'],
          'title' => details.css('h1.product_title').first.text.strip,
          'price' => {
            'amount' => details.css('span.woocommerce-Price-amount.amount').first.text.strip.gsub(/[^0-9.]+/, '').to_f,
            'currency' => 'MXN',
          },
          'img' => imgs,
          'description' => desc,
        }

        record.merge! Hash[specs] if specs

        record
      rescue StandardError => e
        binding.pry
      end
    end

    def scrap_products_list
      puts '[*] Scraping product list...'

      urls = []

      SECTIONS.each do |section|
        page = 1

        loop do
          payload = fetch_json "#{BASE_URL}#{section}/page/#{page}/?loop=60&woo_ajax=1"
          doc = Nokogiri::HTML payload['items']

          page_urls = doc.css('div.product-element-top>a').map { |a| a.attr 'href' }
          urls.concat(page_urls.map { |url| { 'url' => url, 'section' => section } })

          break if payload['nextPage'].blank?

          page += 1
        rescue StandardError => e
          puts "[-] Error scraping product list: #{e.message}"
          binding.pry
          break
        end
      end

      urls
    end

    def fetch_html(url)
      body = fetch_page url
      Nokogiri::HTML body
    end

    def fetch_json(url)
      body = fetch_page url
      JSON.parse body
    end

    def fetch_page(url)
      puts "[*] Scrapping #{url}..."

      res = HTTParty.get url, headers: default_headers

      raise "Bad request! #{res.body}" if res.code != 200

      res.body
    end

    def default_headers
      {
        'User-Agent' => 'Mozilla/5.0 (X11; Linux x86_64; rv:142.0) Gecko/20100101 Firefox/142.0',
        'Accept' => 'image/webp, application/json',
        'Accept-Language' => 'en-US,en;q=0.5',
        'Accept-Encoding' => 'gzip, deflate, br, zstd',
        'X-Requested-With' => 'XMLHttpRequest',
        'Connection' => 'keep-alive',
        'Cookie' => '__cf_bm=mtmwoOFfSm3PFYshoJ3eBaNe6LTCl1ba.UYhMUmQ4L4-1762319728-1.0.1.1-NnLZ8QH9RXpBrLp.kmePDudWfi7Bn1fq8DjU_kdx3XZC34mkyoQw3kQfHrhMV3DPdqNvOKWSt.rUImWJZtqZGsMMomS82rSPGH42ubOhogI; _gcl_au=1.1.833731081.1762318566; newsletter-popup=1; _ga=GA1.2.1714847667.1762318566; _gid=GA1.2.2142166821.1762318566; tn_track=8b6529726fc3324ec5113e896f80b5e5c14526c7%7E3a3eef2c980db2e8d9f9f85bf37f9397b01e5308; x-rand-user=7ec4bfd161aa5e499acde766c63c8a862511a95e%7E3866; tn_tracksession=2675e7b2199cf16d65131eb172883b40b02dc132%7E17dd56264d2a50f92605c7b008499268904f67f5; store_session_payload_1981503=a5be91efb6826f819cb78cf9600339a1cbde7a7b%7EeyJpdiI6IlpianNWbnRjUzZySDVuWHdiOU9OWFE9PSIsInZhbHVlIjoidENnYllKemNXdUt6OU5jNnpWM3JYR0RYTXIvVng4NkRGdmtXTUJCeEZJV3p5eHcrRGM1Ry8vVWJTMy9xclBEbm9zMmorV0VRR1RMdGYrek92dUttcjUySFk4MVNBS3cxUm9rQUN4MGxsSHovaGV6K2x6SWhldDJNQys5YjIvYXBUYWkrZ1NmWDJpR2h1cEZXSXR6Qm9ad0liUHdqczBUS3pOajRuN05MY3kwMWE5RFNqWmFUbTlFYStxeko5UGFqbDhtR1FsSTQvSzUwL05IdU1RMzNKMzNPL0l3cGpsSWhOQnlsMzlreHV3emxueWRQZndsdDlpTEJPcGs1eUFIZ2txZ0Qwa2lUN1pLem95SnZMSkNvelNsMWtQRktsNnJZV2ZjVnFXc2JIKzlxU1A2a2YxYWwwSHN6QUJPRm0xZklEcTFaanpGeG80Y3l1SFFiRS9nWFhnPT0iLCJtYWMiOiJkY2YxMTY1NjE4OTVmNDIwZDU5NzdiM2Y1ZTY3MzIxNTM2MTUwMzBhNmUyZDNmNWNkMWJlNjU4OGE4MjQ1YThlIn0%3D; store_login_session=3be5fcabf721a65238e6e7cedb6c0ad66268ab5f%7Eae4c807e0e484a5cbdce427c3fee3b21297a94d1addc2ce5d49f0d0778c5be8e; _ga_Y01EEPH4TK=GS2.2.s1762318566$o1$g1$t1762320169$j60$l0$h0; _fbp=fb.1.1762318566702.154717759849449291; wpnViewcount=13; TPIDC=hiw3sp-9cwnmtde1-ujhdfbn2t1ar9is5y-eqpdmi48unhwfg-al1-wtc; cwdcc=false; cus=false; wallet-cross-store-impossible=false; _wpnlvusw=1; wpnLastDenial=1762318693034; cookie_consent=1; _wpn_cotpc=1; sdtpc=1',
        'Sec-Fetch-Dest' => 'empty',
        'Sec-Fetch-Mode' => 'cors',
        'Sec-Fetch-Site' => 'same-origin',
        'Priority' => 'u=4',
        'TE' => 'trailers',
      }
    end

    def allowed_keys
      @allowed_keys ||= %w[
        battery
        bb
        capacity
        charger
        color
        description
        diameter
        dimensions
        fire_rate
        firing_mode
        fps_range
        gas
        gearbox
        hardness
        hop_up
        id
        img
        inner_barrel
        length
        magazine
        magnification
        maker
        materials
        mosfet
        motor
        outer_barrel
        package_contents
        performance
        power
        price
        range
        speed
        system
        thread_direction
        title
        trigger
        type
        url
        voltage
        weight
      ]
    end

    def props_dict
      @props_dict ||= {
        'barril_interior' => 'inner_barrel',
        'batera' => 'battery',
        'caja_gearbox' => 'gearbox',
        'caon_interno' => 'inner_barrel',
        'capacidad' => 'capacity',
        'capacidad_cargador' => 'capacity',
        'cargador' => 'magazine',
        'color' => 'color',
        'dimensiones' => 'dimensions',
        'energa' => 'system',
        'fabricante' => 'maker',
        'gas' => 'gas',
        'gatillo_electrnico' => 'trigger',
        'gearbox' => 'gearbox',
        'hop_up' => 'hop_up',
        'hopup' => 'hop_up',
        'incluye' => 'package_contents',
        'inner_barrel' => 'inner_barrel',
        'largo' => 'length',
        'longitud' => 'length',
        'longitud_can_interno' => 'inner_barrel',
        'longitud_mxima' => 'length',
        'modo_disparo' => 'firing_mode',
        'modos_disparo' => 'firing_mode',
        'modos_fuego' => 'firing_mode',
        'mosfet' => 'mosfet',
        'motor' => 'motor',
        'peso' => 'weight',
        'potencia' => 'power',
        'rango_fps' => 'fps_range',
        'rendimiento' => 'performance',
        'rondas_segundo' => 'fire_rate',
        'rosca' => 'thread_direction',
        'sistema' => 'system',
        'tipo_gas' => 'gas',
        'tipo_rosca' => 'thread_direction',
        'tiros_segundo' => 'fire_rate',
        'velocidad_salida' => 'speed',
      }
    end

    def clean_title(value)
      value
    end

    # veta airsoft
    def clean_battery(value)
      capacity = value
                 .scan(/([\d,.]+\s*V\s*(\d+\s*mAh)?)/i)
                 .map(&:first)
                 .compact
                 .uniq
                 .map { |v| v.strip.tr 'v,', 'V.' }

      type = value
             .scan(/(PEQ|LiPo|NiMH|tubo|palo|stick|barra|lapiz|Butterfly|mariposa)/i)
             .map(&:first)
             .compact
             .uniq
             .map(&:strip)

      type = type.map do |t|
        clean = 'PEQ' if t.downcase == 'peq'
        clean = 'LiPo' if t.downcase == 'lipo'
        clean = 'NiMH' if t.downcase == 'nimh'

        clean
      end.compact.uniq

      return [] if capacity.empty? && type.empty?

      [{
        capacity: capacity,
        type: type,
      }]
    end

    def clean_fps_range(value)
      value
    end

    def clean_gearbox(value)
      value
    end

    def clean_hop_up(value)
      value
    end

    def clean_inner_barrel(value)
      value
    end

    def clean_magazine(value)
      value
    end

    def clean_maker(value)
      [value]
    end

    def clean_motor(value)
      value
    end

    def clean_price(value)
      value
    end

    def clean_speed(value)
      value
    end

    def clean_system(value)
      value
    end

    def clean_thread_direction(value)
      value
    end

    def clean_type(value)
      [value]
    end

    def clean_fire_rate(value)
      return [] if value.blank?

      value.split(',').map(&:strip)
    end

    def clean_firing_mode(value)
      return [] if value.blank?

      res = []
      res << 'safety' if value.match?(/seguridad/i)
      res << 'semi' if value.match?(/semi/i)
      res << 'full' if value.match?(/(full|complet)/i)

      res
    end
  end
end

Tactishop.start ARGV
